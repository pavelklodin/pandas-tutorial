# Ментальная модель: чем _Python_-анализ отличается от _Excel_ и _SQL_

## _Excel_

- данные + формулы + визуализация в одном месте;
- удобно для:
  - ручной работы,
  - небольших объёмов,
  - _ad-hoc_ анализа;
- плохо:
  - автоматизируется,
  - масштабируется,
  - воспроизводится.

## _SQL_

- данные живут в БД;
- логика — **декларативная** (`SELECT ... WHERE ... GROUP BY ...`);
- отлично:
  - для больших объёмов,
  - для стандартных запросов;
- ограничено:
  - сложные вычисления,
  - нетривиальная логика,
  - интеграция с _ML_ / статистикой.

## _Python_ (`pandas` + `NumPy`)

- данные загружаются **в память процесса**;
- логика — **императивная** (как программа);
- сильные стороны:
  - сложная логика,
  - расчёты,
  - автоматизация,
  - воспроизводимость;
- ограничения:
  - память,
  - скорость на очень больших объёмах (решается архитектурно).

## Ключевая мысль

_Python_ для анализа данных — это не “замена Excel”, а **программируемый аналитический пайплайн**.

# `NumPy` — основа всего

## Почему обычные списки Python не подходят

`numbers = [1, 2, 3, 4, 5]`

Проблемы:
- каждый элемент — отдельный _Python_-объект;
- большие накладные расходы;
- медленные циклы.

## NumPy array — что это на самом деле

```
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
```

Что происходит под капотом:
- один блок памяти;
- все элементы одного типа;
- операции выполняются на уровне _C_, а не _Python_.

## Векторизация — ключевое слово

`arr * 2`


Это **не цикл**, а:
- одна операция над всем массивом;
- максимально быстро;
- читаемо.

### Аналог “классического” Python:

```
result = []
for x in arr:
    result.append(x * 2)
```

`NumPy` избавляет нас от таких циклов в аналитическом коде.

# Pandas — таблицы, но умные

## Основные структуры данных

| Структура   | Аналог  | Описание                     |
|-------------|---------|------------------------------|
| `Series`    | колонка | одномерный массив с индексом |
| `DataFrame` | таблица | строки + колонки + индексы   |

Пример DataFrame:

| index | date       | region | revenue |
|-------|------------|--------|---------|
| 0     | 2024-01-01 | EU     | 1200    |
| 1     | 2024-01-02 | US     | 900     |

## Индекс — важнее, чем кажется

Индекс:
- это не просто номер строки;
- может быть:
  - датой,
  - строкой,
  - составным ключом.

В _SQL_ это ближе всего к:
- `PRIMARY KEY`,
- но более гибкому.

# `pandas` vs _SQL_ — точное сопоставление

| _SQL_                 | `pandas`              |
|-----------------------|-----------------------|
| `SELECT *`            | `df`                  |
| `WHERE`               | `df.loc[...]`         |
| `GROUP BY`            | `df.groupby(...)`     |
| `ORDER BY`            | `df.sort_values(...)` |
| `JOIN`                | `merge()`             |
| `COUNT`, `SUM`, `AVG` | `agg()`               |

## Важно:

`pandas` **не заменяет** _SQL_, он:
- либо дополняет его,
- либо используется после выгрузки данных.

# Как `pandas` работает с памятью

## Почему _Excel_ “не тянет”, а `pandas` — да

- Excel:
  - UI,
  - формулы,
  - форматирование;
- Pandas:
  - чистые данные,
  - без интерфейса,
  - без лишних накладных расходов.

## Но память всё равно конечна

Pandas:
- не для “бесконечных” данных;
- но:
  - чтение по частям (`chunksize`);
  - фильтрация на входе;
  - агрегация до загрузки в память.

Мы это **обязательно** разберём позже.

# Идиомы pandas (важно для чтения чужого кода)

Некоторые конструкции могут выглядеть непривычно.

## Пример 1

`df["revenue"].mean()`

Это:
- не метод списка,
- а векторная операция над колонкой.

## Пример 2

`df.loc[df["region"] == "EU"]`

Аналог SQL:
```
SELECT *
FROM table
WHERE region = 'EU'
```

# Типичный аналитический пайплайн

Почти любой анализ сводится к:
1. Загрузка данных
2. Проверка качества
3. Очистка
4. Преобразование
5. Агрегация
6. Интерпретация результата

_Python_ хорош тем, что **каждый шаг явно зафиксирован в коде**.

# Что дальше

В следующем шаге я предлагаю:
- взять **простейший, но реалистичный _CSV_**;
- пройти путь:
  - загрузка,
  - фильтрация,
  - агрегация;
  - оформить код как **небольшой production-скрипт**;
- разобрать:
  - каждую конструкцию,
  - каждое “питоновское” решение,
  - без предположения, что вы «должны это знать».

После этого — **первое задание для вас**.